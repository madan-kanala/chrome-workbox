---
layout: jsdoc
title: "Source: sw-cli/src/lib/get-file-manifest-entries.js"
jsdocNav: 
  - Modules:
    - <a href="module-sw-background-sync-queue.html#main">sw-background-sync-queue</a>
    - <a href="module-sw-broadcast-cache-update.html#main">sw-broadcast-cache-update</a>
    - <a href="module-sw-cache-expiration.html#main">sw-cache-expiration</a>
    - <a href="module-sw-cacheable-response.html#main">sw-cacheable-response</a>
    - <a href="module-sw-cli.html#main">sw-cli</a>
    - <a href="module-sw-lib.html#main">sw-lib</a>
    - <a href="module-sw-precaching.html#main">sw-precaching</a>
    - <a href="module-sw-routing.html#main">sw-routing</a>
    - <a href="module-sw-runtime-caching.html#main">sw-runtime-caching</a>
---





    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const getFileDetails = require('./utils/get-file-details');
const filterFiles = require('./utils/filter-files');
const errors = require('./errors');

/**
 * @typedef {Object} ManifestEntry
 * @property {String} url The URL to the asset in the manifest.
 * @property {String} revision The revision details for the file. This is a
 * hash generated by node based on the file contents.
 * @memberof module:sw-cli
 */


/**
 * To get a list of files and revision details that can be used to ultimately
 * precache assets in a service worker.
 *
 * @param {Object} input
 * @param {Array&lt;String>} input.globPatterns  Patterns used to select files to
 * include in the file entries.
 * @param {Array&lt;String>} input.globIgnores  Patterns used to exclude files
 * from the file entries.
 * @param {String} input.rootDirectory The directory run the glob patterns over.
 * @return {Array&lt;ManifestEntry>} An array of ManifestEntries will include
 * a url and revision details for each file found.
 * @memberof module:sw-cli
 */
const getFileManifestEntries = (input) => {
  if (!input || typeof input !== 'object' || input instanceof Array) {
    throw new Error(errors['invalid-get-manifest-entries-input']);
  }

  const globPatterns = input.globPatterns;
  const globIgnores = input.globIgnores;
  const rootDirectory = input.rootDirectory;

  if (typeof rootDirectory !== 'string' || rootDirectory.length === 0) {
    return Promise.reject(
      new Error(errors['invalid-root-directory']));
  }

  const fileSet = new Set();

  const fileDetails = globPatterns.reduce((accumulated, globPattern) => {
    const globbedFileDetails = getFileDetails(
      rootDirectory, globPattern, globIgnores);
    globbedFileDetails.forEach((fileDetails) => {
      if (fileSet.has(fileDetails.file)) {
        return;
      }

      fileSet.add(fileDetails.file);
      accumulated.push(fileDetails);
    });
    return accumulated;
  }, []);

  return filterFiles(fileDetails);
};

module.exports = getFileManifestEntries;
</code></pre>
        </article>
    </section>




