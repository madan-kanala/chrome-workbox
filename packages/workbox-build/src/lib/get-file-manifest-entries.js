const assert = require('assert');

const errors = require('./errors');
const filterFiles = require('./utils/filter-files');
const getCompositeDetails = require('./utils/get-composite-details');
const getFileDetails = require('./utils/get-file-details');
const getStringDetails = require('./utils/get-string-details');
const constants = require('./constants');

/**
 * @typedef {Object} ManifestEntry
 * @property {String} url The URL to the asset in the manifest.
 * @property {String} revision The revision details for the file. This is a
 * hash generated by node based on the file contents.
 * @memberof module:workbox-build
 */

/**
 * To get a list of files and revision details that can be used to ultimately
 * precache assets in a service worker.
 *
 * @param {module:workbox-build.Configuration} input
 * @return {Promise<Array<ManifestEntry>>}
 * An array of {@link module:workbox-build#ManifestEntry|ManifestEntries}
 * which will include a url and revision parameter.
 * @memberof module:workbox-build
 */
async function getFileManifestEntries(input) {
  assert(input && typeof input === 'object' && !Array.isArray(input),
    errors['invalid-get-manifest-entries-input']);

  // staticFileGlobs has been deprecated.
  assert(!input.staticFileGlobs, errors['static-file-globs-deprecated']);

  // dynamicUrlToDependencies has been deprecated.
  assert(!input.dynamicUrlToDependencies, errors['dynamic-url-deprecated']);

  const globPatterns = typeof input.globPatterns !== 'undefined' ?
    input.globPatterns : constants.defaultGlobPatterns;
  const globIgnores = input.globIgnores || constants.defaultGlobIgnores;
  const globDirectory = input.globDirectory;
  const templatedUrls = input.templatedUrls;

  assert(typeof globDirectory === 'string' && globDirectory.length !== 0,
    errors['invalid-glob-directory']);

  assert(globPatterns && Array.isArray(globPatterns),
    errors['invalid-static-file-globs']);

  assert(globIgnores && Array.isArray(globIgnores),
    errors['invalid-glob-ignores']);

  // templatedUrls is optional.
  assert(!templatedUrls ||
    (typeof templatedUrls === 'object' && !Array.isArray(templatedUrls)),
    errors['invalid-templated-urls']);

  assert(globIgnores.every((pattern) => typeof pattern === 'string'),
    errors['invalid-glob-ignores']);

  const fileSet = new Set();

  const fileDetails = globPatterns.reduce((accumulated, globPattern) => {
    const globbedFileDetails = getFileDetails(
      globDirectory, globPattern, globIgnores);
    globbedFileDetails.forEach((fileDetails) => {
      if (fileSet.has(fileDetails.file)) {
        return;
      }

      fileSet.add(fileDetails.file);
      accumulated.push(fileDetails);
    });
    return accumulated;
  }, []);

  if (templatedUrls) {
    for (let url of Object.keys(templatedUrls)) {
      assert(!fileSet.has(url), errors['templated-url-matches-glob']);

      const dependencies = templatedUrls[url];
      if (Array.isArray(dependencies)) {
        const dependencyDetails = dependencies.reduce((previous, pattern) => {
          try {
            const globbedFileDetails = getFileDetails(
              globDirectory, pattern, globIgnores);
            return previous.concat(globbedFileDetails);
          } catch (err) {
            const debugObj = {};
            debugObj[url] = dependencies;
            throw new Error(`${errors['bad-template-urls-asset']} ` +
              `'${pattern}' in templateUrl '${JSON.stringify(debugObj)}' ` +
              `could not be found.`);
          }
        }, []);
        fileDetails.push(getCompositeDetails(url, dependencyDetails));
      } else if (typeof dependencies === 'string') {
        fileDetails.push(getStringDetails(url, dependencies));
      } else {
        throw new Error(errors['invalid-templated-urls']);
      }
    }
  }

  return filterFiles(fileDetails, input);
}

module.exports = getFileManifestEntries;
